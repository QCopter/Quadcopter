def move(self, motion): # Do not change the name of this function
        # motion is given as (steeringangle, distance d)
        # ADD CODE HERE
        alpha = motion[0]
        d = motion[1]
        beta = d * tan(alpha) / self.length
        
        result = robot()
        
        if abs(beta) > 0.001:
            radius = d/beta
            
            cx = self.x - sin(self.orientation) * radius
            cy = self.y + cos(self.orientation) * radius
        
            result.x = cx + sin(self.orientation + beta) * radius
            result.y = cy - cos(self.orientation + beta) * radius
            result.orientation = (self.orientation + beta) % (2*pi)
            
        else:
            result.x = self.x + d * cos(self.orientation)
            result.y = self.y + d * sin(self.orientation)
            result.orientation = self.orientation + beta
        
        return result # make sure your move function returns an instance
                      # of the robot class with the correct coordinates.
def sense(self, add_noise = 1):

	z = []
	for i in range(len(landmarks)):
		bearing = atan2(landmarks[i][0] - self.y,
						landmarks[i][1] - self.x) - self.orientation
		if add_noise:
			bearing += random.gauss(0.0, self.bearing_noise)
		bearing %= 2.0 * pi
		Z.append(bearing)
	return Z